{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.default = jssNested;\n\nvar _warning = require('warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar separatorRegExp = /\\s*,\\s*/g;\nvar parentRegExp = /&/g;\nvar refRegExp = /\\$([\\w-]+)/g;\n/**\n * Convert nested rules to separate, remove them from original styles.\n *\n * @param {Rule} rule\n * @api public\n */\n\nfunction jssNested() {\n  // Get a function to be used for $ref replacement.\n  function getReplaceRef(container) {\n    return function (match, key) {\n      var rule = container.getRule(key);\n      if (rule) return rule.selector;\n      (0, _warning2.default)(false, '[JSS] Could not find the referenced rule %s in %s.', key, container.options.meta || container);\n      return key;\n    };\n  }\n\n  var hasAnd = function hasAnd(str) {\n    return str.indexOf('&') !== -1;\n  };\n\n  function replaceParentRefs(nestedProp, parentProp) {\n    var parentSelectors = parentProp.split(separatorRegExp);\n    var nestedSelectors = nestedProp.split(separatorRegExp);\n    var result = '';\n\n    for (var i = 0; i < parentSelectors.length; i++) {\n      var parent = parentSelectors[i];\n\n      for (var j = 0; j < nestedSelectors.length; j++) {\n        var nested = nestedSelectors[j];\n        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.\n\n        result += hasAnd(nested) ? nested.replace(parentRegExp, parent) : parent + ' ' + nested;\n      }\n    }\n\n    return result;\n  }\n\n  function getOptions(rule, container, options) {\n    // Options has been already created, now we only increase index.\n    if (options) return _extends({}, options, {\n      index: options.index + 1\n    });\n    var nestingLevel = rule.options.nestingLevel;\n    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;\n    return _extends({}, rule.options, {\n      nestingLevel: nestingLevel,\n      index: container.indexOf(rule) + 1\n    });\n  }\n\n  function onProcessStyle(style, rule) {\n    if (rule.type !== 'style') return style;\n    var container = rule.options.parent;\n    var options = void 0;\n    var replaceRef = void 0;\n\n    for (var prop in style) {\n      var isNested = hasAnd(prop);\n      var isNestedConditional = prop[0] === '@';\n      if (!isNested && !isNestedConditional) continue;\n      options = getOptions(rule, container, options);\n\n      if (isNested) {\n        var selector = replaceParentRefs(prop, rule.selector // Lazily create the ref replacer function just once for\n        // all nested rules within the sheet.\n        );\n        if (!replaceRef) replaceRef = getReplaceRef(container // Replace all $refs.\n        );\n        selector = selector.replace(refRegExp, replaceRef);\n        container.addRule(selector, style[prop], _extends({}, options, {\n          selector: selector\n        }));\n      } else if (isNestedConditional) {\n        container // Place conditional right after the parent rule to ensure right ordering.\n        .addRule(prop, null, options).addRule(rule.key, style[prop], {\n          selector: rule.selector\n        });\n      }\n\n      delete style[prop];\n    }\n\n    return style;\n  }\n\n  return {\n    onProcessStyle: onProcessStyle\n  };\n}","map":{"version":3,"sources":["C:/Users/medic/Desktop/CodingBootCamp/Homework/Monnaie/client/node_modules/jss-nested/lib/index.js"],"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","default","jssNested","_warning","require","_warning2","_interopRequireDefault","obj","__esModule","separatorRegExp","parentRegExp","refRegExp","getReplaceRef","container","match","rule","getRule","selector","options","meta","hasAnd","str","indexOf","replaceParentRefs","nestedProp","parentProp","parentSelectors","split","nestedSelectors","result","parent","j","nested","replace","getOptions","index","nestingLevel","undefined","onProcessStyle","style","type","replaceRef","prop","isNested","isNestedConditional","addRule"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = jssNested;\n\nvar _warning = require('warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar separatorRegExp = /\\s*,\\s*/g;\nvar parentRegExp = /&/g;\nvar refRegExp = /\\$([\\w-]+)/g;\n\n/**\n * Convert nested rules to separate, remove them from original styles.\n *\n * @param {Rule} rule\n * @api public\n */\nfunction jssNested() {\n  // Get a function to be used for $ref replacement.\n  function getReplaceRef(container) {\n    return function (match, key) {\n      var rule = container.getRule(key);\n      if (rule) return rule.selector;\n      (0, _warning2.default)(false, '[JSS] Could not find the referenced rule %s in %s.', key, container.options.meta || container);\n      return key;\n    };\n  }\n\n  var hasAnd = function hasAnd(str) {\n    return str.indexOf('&') !== -1;\n  };\n\n  function replaceParentRefs(nestedProp, parentProp) {\n    var parentSelectors = parentProp.split(separatorRegExp);\n    var nestedSelectors = nestedProp.split(separatorRegExp);\n\n    var result = '';\n\n    for (var i = 0; i < parentSelectors.length; i++) {\n      var parent = parentSelectors[i];\n\n      for (var j = 0; j < nestedSelectors.length; j++) {\n        var nested = nestedSelectors[j];\n        if (result) result += ', ';\n        // Replace all & by the parent or prefix & with the parent.\n        result += hasAnd(nested) ? nested.replace(parentRegExp, parent) : parent + ' ' + nested;\n      }\n    }\n\n    return result;\n  }\n\n  function getOptions(rule, container, options) {\n    // Options has been already created, now we only increase index.\n    if (options) return _extends({}, options, { index: options.index + 1 });\n\n    var nestingLevel = rule.options.nestingLevel;\n\n    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;\n\n    return _extends({}, rule.options, {\n      nestingLevel: nestingLevel,\n      index: container.indexOf(rule) + 1\n    });\n  }\n\n  function onProcessStyle(style, rule) {\n    if (rule.type !== 'style') return style;\n    var container = rule.options.parent;\n    var options = void 0;\n    var replaceRef = void 0;\n    for (var prop in style) {\n      var isNested = hasAnd(prop);\n      var isNestedConditional = prop[0] === '@';\n\n      if (!isNested && !isNestedConditional) continue;\n\n      options = getOptions(rule, container, options);\n\n      if (isNested) {\n        var selector = replaceParentRefs(prop, rule.selector\n        // Lazily create the ref replacer function just once for\n        // all nested rules within the sheet.\n        );if (!replaceRef) replaceRef = getReplaceRef(container\n        // Replace all $refs.\n        );selector = selector.replace(refRegExp, replaceRef);\n\n        container.addRule(selector, style[prop], _extends({}, options, { selector: selector }));\n      } else if (isNestedConditional) {\n        container\n        // Place conditional right after the parent rule to ensure right ordering.\n        .addRule(prop, null, options).addRule(rule.key, style[prop], { selector: rule.selector });\n      }\n\n      delete style[prop];\n    }\n\n    return style;\n  }\n\n  return { onProcessStyle: onProcessStyle };\n}"]},"metadata":{},"sourceType":"script"}